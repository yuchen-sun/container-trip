# 理解容器镜像
相信看完了前面的几篇支线分享，你对容器就是个进程的概念有了一定的理解。也应当明白了Linux Namespace技术为容器进程施加了“障眼法”，使得容器看不见其他进程，看不到其他网卡。而Cgroups技术为容器进程画了个”圈”，使得它不能超额使用资源。
那不知道，你有没有想过这些问题呢:

- 容器进程所看到的文件，为什么会是镜像里面的文件？
- 容器进程内对内部文件进行了修改，为什么依赖这个镜像的其他容器没有受到影响？
- 容器进程内对一个文件进行了删除，commit后得到的信镜像，大小为啥没有变化？
- 有经历过，读取镜像中大文件时，监控面板突然飙高的io延迟吗？
## 挂载与Mount Namespace
如果你理解了前面的文章，其实应该可以想到Mount Namespace。通过这个Namespace来限制容器进程的文件系统。
```c
#define _GNU_SOURCE
#include <sys/mount.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <errno.h>
#include <sched.h>
#include <signal.h>
#include <unistd.h>
#define STACK_SIZE (1024 * 1024)
static char container_stack[STACK_SIZE];
char *const container_args[] = {
    "/bin/bash",
    NULL,
};

int container_main(void *arg){
    printf("hello container world!\n");
    // 避免shared的根mount，会继承到子mount ns。
    // 如果继承了，那么在子ns中的更改会影响根ns的文件系统。
    mount("", "/", NULL, MS_PRIVATE, "");
    // 重新挂载test-mount,将其挂载为tmpfs内存
    mount("none", "/test-mount", "tmpfs", 0, "");
    // 执行/bin/bash
    execv(container_args[0], container_args);
    printf("err: %s\n", errno);
    return 1;
}

int main(){
    printf("start a container with a mount namepsace!\n");
    // 创建一个"容器"进程.
    // container_main => 进程执行container_main这个函数
    //  container_stack + STACK_SIZE => 使用的堆栈
    // CLONE_NEWNS | SIGCHLD => 开启新的mount namespace，
    // 并且注册CHLD信号，子进程退出通知父进程
    int container_pid = clone(container_main, container_stack + STACK_SIZE,
                              CLONE_NEWNS | SIGCHLD, NULL);
    // 等待子进程执行完毕
    waitpid(container_pid, NULL, 0);
    printf("bye container!\n");
    return 0;
}
```

上面这段C代码就是创建进程的时候传入了`CLONE_NEWNS`来指定进程使用新的mount namespace。但细心的你应该发现了，在容器开始执行bash之前，有mount操作。这也是mount namespace 与其他namespace不同的地方。它需要mount操作，才会真正的生效。
我们来测试下这段程序（基于Linux系统）：
```bash
root@linux$: mkdir /test-mount
root@linux$: echo a > /test-mount/test.log
root@linux$: gcc ./mount.c -o container-mount-ns
root@linux$: ./container-mount-ns
root@container$: ls /test-mount
root@container$: exit
root@linux$: ls /test-mount
test.log
```
会看到我们在机器上创建的`test.log`文件在容器内看不见了。退出容器后，发现`test.log`依然存在于机器上，这就是mount namespace的魔力。

!!! tips 
    不要小看上面几行系统调用，这是Linux社区努力后的结果。而用GO语言实现的docker项目，为了在有协程语义的go语言中实现clone，采用了非常Linux，非常Golang风格的实现方式。后续与机会再与大家分享，感兴趣的同学，可以点击参考链接自己研究下。[参考链接](https://github.com/moby/moby/tree/master/pkg/reexec)（可以从init的执行顺序与linux中/proc下进程文件的链接入手）

## 镜像-应用的静态诉求
其实基于上面的例子，相信你应该可以大致明白mount namespace对于容器进程的意义了，其实在docker的实现中，并不是mount，而是pivot_root系统调用。其实操作在大致上一致，都是要切换容器的文件系统。在例子中，我们只改变了`/test-mount`这个文件的挂载，而容器项目改变的则是容器进程的`/`目录，将其挂载为镜像中的文件。而这种提供`/`目录的文件，其实有个专业的名字叫rootfs（根文件系统）一个基本的rootfs大致会提供一下这些文件。
```bash
root@linux$: ls /
bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var
```
长久以来，程序的依赖管理一直是程序开发阶段的大问题，无论是java的maven，rust的cargo和go的mould，都是致力于解决依赖的问题，而当程序编译成jar或二进制文件，交付给运维后，这种依赖管理便升级成为了`程序对运行环境的依赖`,而当运维部署好环境之后，程序要是还不能运行，这种依赖管理就会变为`程序对操作系统的依赖`。你会发现，合作开发过程中，想要在自己的环境上，运行别人的程序要经历重重考验。最后可能还会得到一句"我程序没问题，是你环境有问题，你换个系统吧"。

而镜像的存在，就解决了这些问题，因为镜像中包含的不仅仅是应用程序，还有整个系统的文件系统，这是一个程序运行所依赖的最完整的"库"。镜像这种"打包操作系统的能力"，不仅强大，还带来了一个"强一致"的好处。不论你在哪里，pc，服务器，云主机，虚拟机。只要你的架构与镜像支持的架构相同，那么你就可以跑起来这个镜像中的程序。这种一致性，打破了开发与运维之间的屏障，使得软件交付变得便捷，透明。

!!! tips 
    rootfs仅仅只是文件系统，它只包含系统的文件与目录结构，而不包含linux的内核。linux项目分离了静态的文件与runtime的内核，这种分离，模块化系统后，带来的好处便是可维护性的增加。

镜像保存了程序依赖的所有库，在没有运行的时候，就安静的作为静态文件待在磁盘上，而一旦用`docker run`命令启动了镜像后，镜像就会变为容器进程的文件系统，将程序诉求的库全部准备好，同时承担着容器进程的所有文件操作。可以说，正是因为有了镜像，应用程序才有了一个可以保存从操作系统到上层程序依赖的地方。
## 分层-Docker项目的一小步，容器圈子的一大步
有没有想过，如果docker不支持FROM base images这个功能，会是怎样的场景？你打好了一个C++ GRPC的镜像，然后在里面安装了一些你程序的依赖，而其他同事也想用C++ GRPC，但是直接用你的镜像有依赖冲突的问题，这个时候他不得不重新构建一套新的rootfs。

还好，Docker项目支持FROM这个功能，使得我们可以轻松引用别人的基础镜像，在巨人的肩膀上，构建我们的程序。甚至，docker还迈出了一小步，它并没有采用原始的rootfs的打包方式，它做了创新，引入了`layer`层的概念。制作镜像的每一步，都会是新的一层，也就是增量rootfs,最后在镜像运行时，将所有层通过联合文件系统（Union File System）挂载为一个统一文件视图，展示给容器进程。当然，你应该也会想到，这也是Linux支持的功能。目前来看，docker在Linux上一般采用的都是Overlay2作为联合文件系统的后端。

联合文件系统也好理解，它的具体含义就是将不同的目录，合并挂载到同一个目录下。
```bash
root@linux$: mkdir {a,b,c}
root@linux$: echo "a" > a/{a.log,x.log}
root@linux$: echo "b" > b/{b1.log,b2.log,x.log}
root@linux$: mount -t overlay c -o lowerdir=./a:./b ./c
root@linux$: ls c
a.log  b1.log  b2.log  x.log
```
上面的命令，先是创建了3个目录a,b,c。然后在a目录里创建了a.log与x.log两个文件,在b目录里面创建了b1.log,b2.log,x.log三个文件。最后通过mount命令将a,b联合挂载到c目录下。查看c目录下的文件，会发现a,b两个目录下的文件都在c中了。这就是联合文件系统。
!!! 思考
    你是否好奇，a,b中都有的x文件，为啥只在c中看到了一份呢？它们是合并了，还是其中一个覆盖了另一个？自己动手cat x.log试试看。
体会过overlay挂载后，咱们来看看docker是如何使用联合文件系统的。

```bash
root@linux$: docker images
REPOSITORY                                TAG                  IMAGE ID       CREATED         SIZE
192.168.100.21:5000/vipower               latest               d27d26e893ac   3 days ago      22.8MB
docker inspect d27d26e893ac |grep Layers -A 5
            "Layers": [
                "sha256:77cae8ab23bf486355d1b3191259705374f4a11d483b24964d2f729dd8c076a0",
                "sha256:806a69d1d511735d6f7dd0a737cff0aae638b68a4c6bcc8eb5605a1c1958fcfe"
            ]
        },
        "Metadata": {
```
我们用`docker inspect`这个命令来获取这个镜像的详细信息，同时`grep Layers`查看它的分层信息。可以看到这个这个镜像有两层的，那么在`docker run`的时候，docker就会把这两层，利用联合文件系统挂载成为容器进程的根文件系统。
```bash
root@linux$: ls 
```
## 思考¡